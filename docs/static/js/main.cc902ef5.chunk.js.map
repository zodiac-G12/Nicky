{"version":3,"sources":["components/atoms/UseEventListener.tsx","components/atoms/Container.tsx","components/pages/App.tsx","serviceWorker.ts","index.tsx"],"names":["useEventListener","eventName","handler","element","window","savedHandler","useRef","useEffect","current","addEventListener","eventListener","event","removeEventListener","Container","styled","div","indexX","sleep","n","Promise","resolve","setTimeout","flag","direction","onkeydown","e","a","console","log","keyCode","includes","onwheel","deltaX","ontouchstart","changedTouches","clientX","ontouchend","undefined","leftshift","keyframes","rightshift","Md","props","App","content","marked","useState","flags","sf","directions","sd","handlerTS","useCallback","handlerT","handlerK","UseEventListener","dangerouslySetInnerHTML","__html","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","error","ReactDOM","render","StrictMode","document","getElementById","URL","process","href","origin","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.cc902ef5.chunk.js","sourcesContent":["import { useEffect, useRef } from 'react';\n\nexport default function useEventListener(eventName, handler, element = window) {\n    // Create a ref that stores handler\n    const savedHandler = useRef();\n\n    // Update ref.current value if handler changes.\n    // This allows our effect below to always get latest handler ...\n    // ... without us needing to pass it in effect deps array ...\n    // ... and potentially cause effect to re-run every render.\n    useEffect(() => {\n        savedHandler.current = handler;\n    }, [handler]);\n\n    useEffect(\n        () => {\n            // Make sure element supports addEventListener\n            const isSupported = element && element.addEventListener;\n            if (!isSupported) return;\n\n            // Create event listener that calls handler function stored in ref\n            const eventListener = event => savedHandler.current(event);\n\n            // Add event listener\n            element.addEventListener(eventName, eventListener);\n\n            // Remove event listener on cleanup\n            return () => {\n                element.removeEventListener(eventName, eventListener);\n            };\n        },\n        [eventName, element] // Re-run if eventName or element changes\n    );\n}\n","import styled from 'styled-components';\n\nconst Container = styled.div`\n    width: calc(100vw - 10vh);\n    height: 90vh;\n    padding: 5vh;\n    // background: black;\n    // color: orange;\n`;\n\nexport default Container;\n\n// const Back = styled.div`\n//     font-size: 10vh;\n//     width: 100vw;\n//     height: 30vh;\n//     // background: green;\n//     color: orange;\n//     text-align: center;\n//     line-height: 30vh;\n// `;\n//\n// const Crown = styled.div`\n//     width: 100vw;\n//     height: 10vh;\n//     background: crimson;\n// `;\n//\n// const Box = styled.div`\n//     width: 50vw;\n//     margin-left: 25vw;\n//     height: 20vh;\n//     border-radius: 5vh;\n//     text-align: center;\n//     font-size: 5vh;\n//     line-height: 20vh;\n//     color: white;\n//     backdrop-filter: blur(8px);\n//     margin-top: -25vh;\n//     background: rgba(255,255,255,0.1);\n// `;\n","import React, {useState, useCallback} from 'react';\nimport styled, {keyframes} from 'styled-components';\nimport marked from 'marked';\nimport UseEventListener from '../atoms/UseEventListener';\nimport Container from '../atoms/Container';\n\nconst sleep = (n) => new Promise(resolve => setTimeout(resolve, n));\n\n\nlet flag = false,\n    direction = 0;\n\nconst onkeydown = async(e) => {\n    console.log(\"onkeydown\", e);\n    const keyCode = e.keyCode;\n    if (![37,39].includes(keyCode)) return;\n    if (flag) return;\n    if (keyCode === 37) {\n        direction = 37;\n        flag = true;\n        await sleep(550);\n        flag = false;\n    } else if (keyCode === 39) {\n        direction = 39;\n        flag = true;\n        await sleep(550);\n        flag = false;\n    }\n}\n\nconst onwheel = async(e) => {\n    if (flag) return;\n\n    if (e.deltaX > 100) {\n        direction = 37;\n        flag = true;\n        await sleep(550);\n        flag = false;\n    } else if (e.deltaX < -100) {\n        direction = 39;\n        flag = true;\n        await sleep(550);\n        flag = false;\n    }\n}\n\nlet indexX;\n\nconst ontouchstart = async(e) => {\n    if (flag) return;\n\n    if (e.changedTouches) {\n        indexX = e.changedTouches[0].clientX;\n    } else indexX = e.clientX;\n}\nconst ontouchend = async(e) => {\n\n    if (flag) return;\n\n    const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;\n\n    if (indexX < clientX && clientX - indexX > 100) {\n        direction = 39;\n        flag = true;\n        await sleep(550);\n        flag = false;\n        indexX = undefined;\n    } else if (indexX > clientX && indexX - clientX > 100) {\n        direction = 37;\n        flag = true;\n        await sleep(550);\n        flag = false;\n        indexX = undefined;\n    } else {\n        flag = false;\n        indexX = undefined;\n    }\n\n}\n\nconst App = () => {\n    const content = marked(\"# Test\");\n    const [flags, sf] = useState(false);\n    const [directions, sd] = useState(0);\n\n    const handlerTS = useCallback(async(e) => {\n        console.log(\"handlerTS\")\n        ontouchstart(e);\n\n        sf(flag);\n        sd(direction);\n    }, []);\n    const handlerT = useCallback(async(e) => {\n        console.log(\"handlerT\")\n        ontouchend(e);\n\n        sf(flag);\n        sd(direction);\n\n        if (flag) await sleep(600);\n\n        sf(flag);\n        sd(direction);\n    }, []);\n    const handlerK = useCallback(async(e) => {\n        console.log(\"handlerK\")\n        onkeydown(e);\n\n        sf(flag);\n        sd(direction);\n\n        if (flag) await sleep(600);\n\n        sf(flag);\n        sd(direction);\n    }, []);\n    const handlerW = useCallback(async(e) => {\n        console.log(\"handlerW\")\n        onwheel(e);\n\n        sf(flag);\n        sd(direction);\n\n        if (flag) await sleep(600);\n\n        sf(flag);\n        sd(direction);\n    }, []);\n\n    UseEventListener('wheel', handlerW);\n    UseEventListener('keydown', handlerK);\n    UseEventListener('touchstart', handlerTS);\n    UseEventListener('touchend', handlerT);\n    UseEventListener('mouseup', handlerT);\n    UseEventListener('mousedown', handlerTS);\n\n    return (\n        <Container> \n            <Md\n                flag={flags}\n                direction={directions}\n                dangerouslySetInnerHTML={{__html: content}}>\n            </Md>\n        </Container>\n    );\n};\n\nconst leftshift = keyframes`\n    0% {\n        transform: translateX(0);\n    }\n    100% {\n        transform: translateX(-100vw);\n    }\n`;\nconst rightshift = keyframes`\n    0% {\n        transform: translateX(0);\n    }\n    100% {\n        transform: translateX(100vw);\n    }\n`;\n\nconst Md = styled.div`\n    width: 100%;\n    height: 100%;\n    background: red;\n    animation: ${props => {\n        if (!props.flag) return \"none\";\n        if (props.direction === 37) {\n            return leftshift;\n        } else if(props.direction === 39) {\n            return rightshift;\n        } else return \"none\";\n    }} 0.5s ease-out forwards;\n`;\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/pages/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}